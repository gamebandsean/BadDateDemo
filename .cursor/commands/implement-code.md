# Implement Code

Takes code generated by `write-code` and organizes it into proper file structure with independent, well-separated components.

## Overview

This command takes the complete code logic generated by `write-code` and divides it into appropriate files following the project's structure and best practices. It creates independent, modular components that can be maintained and tested separately.

**Important**: This command should:
- Divide code into logical, independent files
- Follow the project's existing file structure and conventions
- Create proper separation of concerns
- Ensure files are independently maintainable
- Create necessary folder structures
- NOT modify the code logic (only organize it)
- NOT write tests (that's handled by `implement-tests`)

## Steps

1. **Locate Code to Implement**
   - If code was just generated by `write-code`, use that code
   - If a file path is provided containing the code, read that file
   - If code is provided directly in the request, use that
   - If no code is provided, ask the user to either:
     - Run `write-code` first to generate the code
     - Provide the code to implement
     - Provide a path to a file containing the code

2. **Analyze Code Structure**
   - Read the complete code logic
   - Identify distinct components (classes, interfaces, enums, etc.)
   - Identify dependencies between components
   - Identify shared utilities or helpers
   - Understand the logical grouping of functionality
   - Note any data structures or configuration that should be separate

3. **Understand Project Structure**
   - Examine the existing codebase structure
   - Identify where similar code is located
   - Understand naming conventions for files and folders
   - Check for existing patterns of code organization
   - Identify the appropriate namespace/folder structure
   - If the project structure is unclear, ask the user for guidance

4. **Plan File Organization**
   - Determine how many files are needed
   - Group related functionality together
   - Separate concerns (e.g., data models, logic, interfaces)
   - Identify shared code that should be in common files
   - Plan folder structure if needed
   - Ensure each file has a single, clear responsibility
   - Consider dependencies and import relationships

5. **Create File Structure**
   - Create necessary folders if they don't exist
   - Create each file with appropriate naming
   - Use the project's naming conventions (PascalCase, camelCase, etc.)
   - Ensure file names clearly indicate their purpose
   - Place files in appropriate locations within the project structure

6. **Split Code into Files**
   - Distribute code components into appropriate files
   - Ensure each file is complete and compilable
   - Add necessary using/import statements to each file
   - Maintain proper namespace/package organization
   - Ensure all dependencies are properly referenced
   - Keep related functionality together
   - Separate interfaces from implementations where appropriate

7. **Verify File Independence**
   - Ensure each file can be understood independently
   - Verify that dependencies are clear and explicit
   - Check that files don't have circular dependencies
   - Ensure proper encapsulation and access modifiers
   - Verify that the code structure makes sense
   - Check that files follow single responsibility principle

8. **Update Related Files**
   - Update any existing files that need to reference the new code
   - Add necessary registrations or initializations
   - Update configuration files if needed
   - Ensure integration points are properly connected
   - Update any dependency injection or factory patterns

9. **Verify Implementation**
   - Check that all files compile (if possible to verify)
   - Ensure no code was lost in the splitting process
   - Verify that the logic remains intact
   - Check that file organization makes sense
   - Ensure the code follows project conventions

10. **Update Task Status**
    - Update the task status to `review` in the task file
    - Mark relevant task checkboxes as complete
    - Note that code has been implemented and is ready for review

11. **Update Changelog**
    - Read the existing `CHANGELOG.md` file (create if it doesn't exist)
    - Append a new entry at the top with:
      - Current date and time (ISO 8601 format: YYYY-MM-DD HH:MM:SS)
      - Command name: `implement-code`
      - Files changed: List the created/modified files
    - Format: `[YYYY-MM-DD HH:MM:SS] implement-code: Created [list of files]`
    - Keep entries minimal and chronological (newest first)

## File Organization Principles

- **Single Responsibility**: Each file should have one clear purpose
- **Logical Grouping**: Related functionality should be in the same file or nearby files
- **Clear Dependencies**: Dependencies should be explicit and minimal
- **Maintainability**: Files should be easy to understand and modify independently
- **Project Conventions**: Follow existing project structure and naming patterns

## Notes

- This command organizes code, it doesn't modify logic
- Code should be split into logical, maintainable units
- Each file should be independently understandable
- Dependencies between files should be clear and minimal
- The resulting structure should follow project conventions

