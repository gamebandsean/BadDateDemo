# Generate Implementation Plan

Generates an implementation plan with task lists based on a game design document created by the generate-game-design command.

## Overview

This command reads a `docs/game-design.md` file (generated by the `generate-game-design` command) and optionally a `docs/project.md` file to create a structured implementation plan. The plan consists of task lists organized by game mechanics, with clear status tracking. Tasks are stored in individual files within a `docs/tasks` folder, with a main overview file providing high-level organization.

**Important**: This command should:
- Create task lists based on game mechanics, not code structure
- Focus on what needs to be implemented, not how to implement it
- Organize tasks logically by mechanic/system
- Identify and document dependencies between mechanics
- Calculate and document implementation order based on dependencies
- Provide clear status tracking (todo/progress/review/done)
- Keep task files focused on tasks and status only
- Create a separate overview file for general information

## Steps

1. **Locate Game Design Document**
   - Look for `docs/game-design.md` in the workspace root
   - If a specific path is provided, use that path
   - If the document doesn't exist, ask the user to either:
     - Provide the path to an existing `game-design.md` file
     - Run `generate-game-design.md` first to create the game design document
     - Provide a brief game design description to analyze

2. **Locate Project Description (Optional)**
   - Look for `docs/project.md` in the workspace root
   - Read it if available to gain additional context about the project
   - Use project information to better understand the scope and priorities
   - If docs/project.md is missing, proceed with docs/game-design.md only

3. **Check Changelog for Updates**
   - Read the `CHANGELOG.md` file in the workspace root (if it exists)
   - Identify recent changes to `docs/game-design.md` (look for entries from `generate-game-design` command)
   - Identify recent changes to `docs/project.md` (look for entries from `define-project` command)
   - Note the timestamps of the most recent updates to both files
   - If `docs/tasks/` folder exists, check if task files were generated before the most recent `docs/game-design.md` or `docs/project.md` updates
   - If either file has been updated since the last task generation, note that tasks need to be updated to reflect these changes
   - Use this information to determine whether to create new task files or update existing ones
   - Identify which specific mechanics or sections have changed based on the changelog entries

4. **Analyze Game Design Document**
   - Read the `docs/game-design.md` file completely
   - Identify all core mechanics listed in the document
   - Identify all secondary mechanics
   - Note mechanic interactions and dependencies
   - For each mechanic, identify which other mechanics it depends on:
     - Direct dependencies (this mechanic requires another mechanic to function)
     - Indirect dependencies (this mechanic works better with another mechanic)
     - Optional dependencies (this mechanic can work without it, but benefits from it)
   - Identify tweakable parameters that need to be implemented
   - Understand the overall structure and organization of mechanics
   - Build a dependency graph of all mechanics
   - If the game design document is vague or missing critical information, ask clarifying questions about:
     - Which mechanics are highest priority
     - Any specific implementation constraints or requirements
     - Whether all mechanics should be included or if some are optional
     - Dependencies between mechanics if not clearly stated

5. **Create or Update Tasks Folder Structure**
   - Create a `docs` folder in the workspace root if it doesn't exist
   - Create a `docs/tasks` folder if it doesn't exist
   - Organize tasks by mechanic/system
   - Each mechanic should have its own task file
   - Use descriptive filenames based on mechanic names (e.g., `paddle-movement.md`, `ball-physics.md`)
   - Use kebab-case for filenames
   - If updating existing tasks (based on changelog):
     - Identify which task files correspond to changed mechanics
     - Preserve existing task statuses where mechanics haven't changed
     - Mark new or modified mechanics for task updates

6. **Calculate Implementation Order**
   - Based on the dependency graph from step 4, calculate the implementation order:
     - Use topological sorting to determine a valid order
     - Mechanics with no dependencies should be implemented first
     - Mechanics that depend on others should be implemented after their dependencies
     - If circular dependencies are detected, note them and ask the user for clarification
   - Assign an implementation order number to each mechanic (1 = first, 2 = second, etc.)
   - Group mechanics into implementation phases if helpful:
     - Phase 1: Foundation mechanics (no dependencies)
     - Phase 2: Mechanics that depend on Phase 1
     - Phase 3: Mechanics that depend on Phase 2, etc.
   - Note any mechanics that can be implemented in parallel (no dependencies between them)

7. **Generate or Update Task Lists for Each Mechanic**
   - For each core mechanic identified:
     - If task file exists and mechanic has changed (based on changelog):
       - Read existing task file to preserve completed tasks
       - Add new tasks for new aspects of the mechanic
       - Update or remove tasks for aspects that have changed or been removed
       - Preserve task statuses for unchanged aspects
       - Update dependencies if they have changed
     - If task file doesn't exist or mechanic is new:
       - Create a task file in the `docs/tasks` folder
       - Break down the mechanic into implementable tasks
     - Each task should be:
       - Specific and actionable
       - Focused on implementing a single aspect of the mechanic
       - Independent enough to be worked on separately (where possible)
     - Tasks should cover:
       - Core functionality implementation
       - Parameter configuration/exposure
       - Integration with other mechanics
       - Testing/validation requirements
   - For each secondary mechanic:
     - Create task file if mechanic is substantial enough
     - Or group related secondary mechanics into a single file
   - For shared systems (e.g., parameter management, save system):
     - Create separate task files as needed
   - For mechanics that have been removed (based on changelog):
     - Remove corresponding task files or mark them as obsolete

8. **Format Task Files**
   - Each task file should follow this structure:
     ```markdown
     # [Mechanic Name] Tasks
     
     ## Status: [Overall status: todo/progress/review/done]
     
     ## Implementation Order: [Order number]
     
     ## Depends On
     - [Mechanic Name 1](mechanic-name-1.md) - [Required/Optional]
     - [Mechanic Name 2](mechanic-name-2.md) - [Required/Optional]
     - (None if no dependencies)
     
     ## Tasks
     
     - [ ] [Task description] - Status: todo
     - [ ] [Task description] - Status: todo
     - [ ] [Task description] - Status: progress
     - [x] [Task description] - Status: done
     ```
   - Include the implementation order number from step 6
   - List all dependencies with links to their task files
   - Mark each dependency as "Required" (must be implemented first) or "Optional" (beneficial but not required)
   - Use checkbox format for tasks (`- [ ]` for incomplete, `- [x]` for complete)
   - Include status in each task line for easy scanning
   - Group related tasks under subheadings if needed
   - Keep descriptions concise but clear
   - Do NOT include code, implementation details, or technical specifications
   - Focus on WHAT needs to be done, not HOW

9. **Create or Update Overview File**
   - Create or update `docs/tasks/OVERVIEW.md` in the tasks folder
   - If updating (based on changelog):
     - Preserve existing content that's still valid
     - Update sections affected by mechanic changes
     - Add notes about recent updates if relevant
   - Include:
     - Brief summary of the implementation plan
     - Implementation order section showing:
       - Ordered list of mechanics by implementation phase/order
       - Which mechanics can be implemented in parallel
       - Visual representation of the dependency graph (if helpful)
     - List of all mechanics/systems with links to their task files
     - Overall progress summary
     - Dependencies section showing:
       - Dependency graph (which mechanics depend on others)
       - Required vs optional dependencies
       - Circular dependency warnings (if any)
     - Priority recommendations (if applicable)
     - General notes about the implementation approach
   - Keep this file focused on high-level organization and context
   - Do NOT include individual task details (those belong in individual task files)

10. **Create or Update Main Task Index**
   - Create or update `docs/tasks/README.md` or `docs/tasks/INDEX.md` in the tasks folder
   - If updating (based on changelog):
     - Update the list to reflect new, removed, or modified mechanics
     - Recalculate progress based on current task statuses
     - Update implementation order if dependencies have changed
   - This file should:
     - List all task files organized by implementation order
     - Show implementation order number for each mechanic
     - List dependencies for each mechanic
     - Provide quick navigation to all mechanics
     - Show progress at a glance (e.g., "5/10 mechanics complete")
     - Use status badges or indicators for quick visual scanning
   - Format example:
     ```markdown
     # Implementation Tasks
     
     ## Progress: 2/10 Complete
     
     ## Implementation Order
     
     ### Phase 1: Foundation (Order 1-3)
     - **Order 1**: [Paddle Movement](paddle-movement.md) - Status: done - Depends on: (None)
     - **Order 2**: [Ball Physics](ball-physics.md) - Status: progress - Depends on: [Paddle Movement](paddle-movement.md)
     - **Order 3**: [Block Destruction](block-destruction.md) - Status: todo - Depends on: [Ball Physics](ball-physics.md)
     
     ### Phase 2: Systems (Order 4-6)
     - **Order 4**: [Power-up System](power-up-system.md) - Status: todo - Depends on: [Ball Physics](ball-physics.md), [Block Destruction](block-destruction.md)
     ...
     ```
   - Group mechanics by implementation phase if applicable
   - Show which mechanics can be worked on in parallel

11. **Set Initial Task Statuses**
   - For new tasks: start with status: `todo`
   - For existing tasks: preserve their current status (don't reset completed tasks)
   - Mark overall mechanic status based on current task completion
   - If user provides priorities, you may mark some as higher priority (but still `todo`)
   - Note that mechanics should be implemented in the order determined in step 6

12. **Update Changelog**
    - Read the existing `CHANGELOG.md` file in the workspace root (create it if it doesn't exist)
    - Append a new entry at the top with:
      - Current date and time (ISO 8601 format: YYYY-MM-DD HH:MM:SS)
      - Command name: `generate-implementation-plan`
      - Files changed: `docs/tasks/` folder (or list specific task files if only a few were created/modified)
    - Format: `[YYYY-MM-DD HH:MM:SS] generate-implementation-plan: Updated docs/tasks/`
    - Keep entries minimal and chronological (newest first)
    - Save the changelog file

13. **Review and Present**
    - Present the generated task structure to the user
    - Show the overview file and explain the organization
    - Highlight the implementation order and dependency structure
    - Verify that tasks are appropriately broken down
    - Confirm that all mechanics from the game design are covered
    - Check that task descriptions are clear and actionable
    - Verify that dependencies are correctly identified
    - Check that implementation order makes sense
    - Refine based on feedback

## Task Status Guidelines

- **todo**: Task has not been started
- **progress**: Task is currently being worked on
- **review**: Task is complete but needs review/testing
- **done**: Task is complete and verified

## Output Structure

```
docs/
├── project.md - Project description
├── game-design.md - Game design document
└── tasks/
    ├── README.md (or INDEX.md) - Main task index with status overview
    ├── OVERVIEW.md - General overview and context
    ├── paddle-movement.md - Paddle movement tasks
    ├── ball-physics.md - Ball physics tasks
    ├── block-destruction.md - Block destruction tasks
    ├── power-up-system.md - Power-up system tasks
    └── ... (other mechanic task files)
```

## Notes

- Task files should be focused and scannable - avoid lengthy descriptions
- Each task should be a single, clear action item
- Group related subtasks under the same mechanic file
- Dependencies between mechanics should be clearly documented:
  - In each task file's "Depends On" section
  - In the OVERVIEW.md dependency graph
  - In the README.md implementation order
- Implementation order should be followed to avoid blocking dependencies
- Mechanics with no dependencies can be implemented in parallel
- Status tracking should be easy to update manually
- Task descriptions should be implementation-agnostic (no code, no specific technologies)
- If circular dependencies are detected, they should be resolved by breaking one dependency or asking the user for clarification

