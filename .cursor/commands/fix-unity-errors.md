# Fix Unity Errors

Automatically fixes bugs and issues reported by the Unity Log Logger utility by analyzing log files and applying appropriate fixes.

## Overview

This command reads the Unity log files generated by the UnityLogLogger utility and attempts to automatically fix common issues. The logger captures all Unity logs (Log, Warning, Error, Exception, Assert), so this command filters for errors, warnings, exceptions, and assertions to identify fixable problems and applies corrections to the codebase.

**Important**: This command should:
- Read and parse the Unity log files generated by UnityLogLogger (JSON format preferred)
- Filter for errors, warnings, exceptions, and assertions (ignore regular Log entries)
- Handle duplicate entries that may exist in the log files
- Analyze error messages and stack traces to identify root causes
- Apply automatic fixes for common issues (null references, missing components, syntax errors, etc.)
- Provide clear explanations of what was fixed
- Ask for clarification when fixes are ambiguous or risky
- Prioritize errors over warnings
- Handle multiple errors systematically

## Steps

1. **Locate Log Files**
   - Check for `unity-logs.json` in the project root directory (generated by UnityLogLogger)
   - If JSON file doesn't exist, check for `unity-logs.log` (text format)
   - If neither exists, inform the user that no log files are available
   - If the user specifies a different log file path, use that instead
   - If multiple log files exist, prefer the most recent one
   - Note: The log files contain ALL Unity logs, including regular Debug.Log messages

2. **Parse Log File**
   - Read the JSON log file (preferred) or parse the text log file
   - Filter entries to only process: Error, Warning, Exception, and Assert types
   - Ignore regular Log entries (Debug.Log messages) unless specifically requested
   - Extract all error/warning/exception entries with their:
     - Type (Error, Warning, Exception, Assert)
     - Message
     - Stack trace
     - Timestamp (for reference)
   - Note that the log may contain duplicate entries (the logger doesn't filter duplicates)
   - Group errors by type (prioritize Errors and Exceptions)
   - If the log format is unclear or corrupted, ask the user for clarification

3. **Analyze Error Patterns**
   - Identify common error patterns:
     - Null reference exceptions
     - Missing component references
     - Missing using/import statements
     - Type mismatches
     - Missing method/field/property definitions
     - Compilation errors
     - Missing GameObject references
     - Serialization issues
   - Extract file paths and line numbers from stack traces when available
   - Identify the affected files and code locations
   - Categorize errors by fixability (automatic, semi-automatic, manual)

4. **Prioritize Errors**
   - Sort errors by severity: Exceptions > Errors > Warnings > Assertions
   - Group errors by file to fix related issues together
   - Identify root causes that may be causing multiple errors
   - Focus on compilation errors first (they block other fixes)
   - Then address runtime errors
   - Finally address warnings if time permits

5. **Read Affected Files**
   - Read all files mentioned in error stack traces
   - Read files that are likely related to the errors
   - Understand the context and code structure
   - Identify dependencies and relationships between files
   - If a file doesn't exist or can't be read, note it for manual review

6. **Apply Automatic Fixes**
   - For each fixable error, apply the appropriate fix:
     - **Null Reference Exceptions**: Add null checks or initialize references
     - **Missing Components**: Add required component references or FindObjectOfType calls
     - **Missing Using Statements**: Add necessary using/import statements
     - **Type Mismatches**: Fix type declarations or casts
     - **Missing Methods/Fields**: Add missing definitions or fix references
     - **Compilation Errors**: Fix syntax errors, missing brackets, etc.
     - **Missing GameObject References**: Add proper initialization or serialization
     - **Serialization Issues**: Add [SerializeField] attributes or fix serialization
   - Make one fix at a time and verify it addresses the error
   - If a fix is ambiguous or could have multiple interpretations, ask the user for clarification
   - If a fix is risky or could break other code, ask for confirmation before applying

7. **Verify Fixes**
   - After applying fixes, check if the error would be resolved
   - Verify that fixes don't introduce new errors
   - Ensure code still compiles (if possible to verify)
   - Check that the fix aligns with project conventions
   - If a fix doesn't resolve the error, try an alternative approach or mark for manual review

8. **Document Manual Fixes Needed**
   - For errors that can't be automatically fixed, create a summary:
     - List the error type and message
     - Explain why it can't be auto-fixed
     - Provide suggestions for manual fixes
     - Include file paths and line numbers
   - Present this summary to the user after automatic fixes are complete

9. **Update Related Files**
   - If fixes require changes to multiple files, update all related files
   - Ensure consistency across the codebase
   - Update any configuration files if needed
   - Fix any cascading errors caused by the initial fixes

10. **Summary and Next Steps**
    - Provide a summary of:
      - Number of errors analyzed
      - Number of errors automatically fixed
      - Number of errors requiring manual intervention
      - List of files modified
    - Suggest next steps (e.g., re-run Unity to verify fixes, check specific files)
    - If all errors are fixed, suggest clearing the log using "Tools/Unity Log Logger/Clear Logs" menu item

11. **Update Changelog**
    - Read the existing `CHANGELOG.md` file (create if it doesn't exist)
    - Append a new entry at the top with:
      - Current date and time (ISO 8601 format: YYYY-MM-DD HH:MM:SS)
      - Command name: `fix-unity-errors`
      - Summary of fixes applied
    - Format: `[YYYY-MM-DD HH:MM:SS] fix-unity-errors: Fixed [number] errors in [list of files]`
    - Keep entries minimal and chronological (newest first)

## Error Fix Patterns

### Null Reference Exceptions
- Add null checks before accessing members
- Initialize references in Awake/Start methods
- Use null-conditional operators (?.) where appropriate
- Add defensive programming checks

### Missing Component References
- Add [SerializeField] private fields for component references
- Initialize in Awake() using GetComponent or FindObjectOfType
- Add validation in Start() to ensure components are assigned

### Missing Using Statements
- Identify the required namespace from the error
- Add using statement at the top of the file
- Verify the namespace is available in the project

### Type Mismatches
- Check the actual type vs expected type
- Add explicit casts if safe
- Fix variable declarations if incorrect
- Update method signatures if needed

### Compilation Errors
- Fix syntax errors (missing brackets, semicolons, etc.)
- Fix method signatures
- Fix class/interface definitions
- Resolve naming conflicts

## Notes

- The UnityLogLogger captures ALL Unity logs, so filter for Error/Warning/Exception/Assert types
- Log files may contain duplicate entries (the logger doesn't filter duplicates)
- When processing duplicates, fix the error once and note that it appeared multiple times
- Always ask for clarification if an error is ambiguous or could be fixed multiple ways
- Prioritize safety - don't make risky changes without confirmation
- Fix one error at a time when possible to avoid cascading issues
- Preserve existing code style and conventions
- Document why certain errors couldn't be auto-fixed
- Consider the broader context of the codebase when making fixes

