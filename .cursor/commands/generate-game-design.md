# Generate Game Design

Generates a game design document focused on game mechanics by analyzing a project.md file created by the define-project command.

## Overview

This command reads a `docs/project.md` file (generated by the `define-project` command) and creates a comprehensive game design document that focuses exclusively on game mechanics. The output is structured to help programmers understand what mechanics need to be implemented, without getting into UI flows, game flows, or implementation details.

**Important**: This command should:
- Focus solely on game mechanics and their behavior
- Explain mechanics in a way that programmers can understand what needs to be implemented
- Identify what should be tweakable/parameterized for game designers
- NOT explain UI flows, game flows, or how mechanics are implemented
- NOT provide implementation details or code structure

## Steps

1. **Locate Project Description**
   - Look for `docs/project.md` in the workspace root
   - If a specific path is provided, use that path
   - If the document doesn't exist, ask the user to either:
     - Provide the path to an existing `project.md` file
     - Run `define-project.md` first to create the project description
     - Provide a brief project description to analyze

2. **Check Changelog for Updates**
   - Read the `CHANGELOG.md` file in the workspace root (if it exists)
   - Identify recent changes to `docs/project.md` (look for entries from `define-project` command)
   - Note the timestamp of the most recent `docs/project.md` update
   - If `docs/game-design.md` exists, check if it was generated before the most recent `docs/project.md` update
   - If `docs/project.md` has been updated since the last `docs/game-design.md` generation, note that the game design document needs to be updated to reflect these changes
   - Use this information to determine whether to create a new game design document or update an existing one

3. **Analyze Project Description**
   - Read the `docs/project.md` file completely
   - Extract core gameplay concepts and mechanics mentioned
   - Identify implicit mechanics based on the game type and similar games referenced
   - Note any roguelike, progression, or procedural generation elements
   - If the project description is vague or missing critical information about mechanics, ask clarifying questions about:
     - Core gameplay loop and primary actions
     - Player interactions and controls
     - Game systems (combat, movement, progression, etc.)
     - Progression mechanics (permanent, temporary, run-based)
     - Procedural generation requirements
     - Power-ups, items, or upgrades
     - Win/loss conditions
     - Difficulty scaling or balancing factors

4. **Identify Core Game Mechanics**
   - Break down the game into distinct mechanical systems
   - For each mechanic, identify:
     - What the mechanic does (behavior and rules)
     - When it applies (triggers, conditions)
     - What entities/objects are involved
     - How it interacts with other mechanics
     - What parameters control its behavior
   - Focus on mechanics, not flows or UI:
     - Example: "Ball bounces off paddle with angle based on hit position" (mechanic)
     - NOT: "Player clicks start button, sees main menu, then gameplay starts" (flow)
   - Organize mechanics into logical groups (e.g., "Ball Physics", "Block Destruction", "Power-ups", "Progression")

5. **Define Mechanic Specifications**
   - For each identified mechanic, create a clear specification that includes:
     - **Mechanic Name**: Clear, descriptive name
     - **Description**: What the mechanic does and its purpose
     - **Rules**: Specific rules and behaviors (e.g., "Ball velocity increases by 10% after each block hit")
     - **Inputs/Triggers**: What causes this mechanic to activate
     - **Outputs/Effects**: What happens as a result
     - **Interactions**: How it relates to other mechanics
     - **Tweakable Parameters**: What values should be exposed for designers to adjust (e.g., "Ball speed multiplier", "Block health", "Power-up spawn rate")
   - Use clear, unambiguous language that programmers can interpret
   - Avoid implementation details (don't specify data structures, algorithms, or code patterns)

6. **Identify Tweakable Parameters**
   - For each mechanic, identify values that should be configurable:
     - Numeric values (speeds, damage, health, timers, etc.)
     - Probabilities (spawn rates, drop chances, etc.)
     - Multipliers and scaling factors
     - Thresholds and limits
   - Group parameters logically (e.g., "Ball Physics Parameters", "Block Parameters", "Power-up Parameters")
   - Note which parameters might need to be adjusted during playtesting/balancing
   - Suggest reasonable default ranges or values if context allows

7. **Create or Update Game Design Document**
   - Create a `docs` folder in the workspace root if it doesn't exist
   - If `docs/game-design.md` exists and `docs/project.md` has been updated (based on changelog):
     - Read the existing `docs/game-design.md` to understand current structure
     - Update sections that are affected by changes in `docs/project.md`
     - Preserve mechanics that are still valid
     - Add new mechanics based on new project description elements
     - Remove or update mechanics that no longer apply
   - If `docs/game-design.md` doesn't exist or needs complete regeneration:
     - Structure the document with clear sections:
       - **Overview**: Brief summary of the game's mechanical focus
       - **Core Mechanics**: Detailed breakdown of primary gameplay mechanics
       - **Secondary Mechanics**: Supporting or optional mechanics
       - **Mechanic Interactions**: How different mechanics work together
       - **Tweakable Parameters**: Comprehensive list of designer-configurable values
   - Use clear headings and subheadings
   - Format mechanics consistently throughout
   - Include examples or edge cases where helpful for clarity

8. **Save Game Design Document**
   - Save the document as `docs/game-design.md`
   - Ensure the file is well-formatted and readable
   - Use markdown formatting for clarity (headers, lists, code blocks for parameter names)

9. **Update Changelog**
   - Read the existing `CHANGELOG.md` file in the workspace root (create it if it doesn't exist)
   - Append a new entry at the top with:
     - Current date and time (ISO 8601 format: YYYY-MM-DD HH:MM:SS)
     - Command name: `generate-game-design`
     - File changed: `docs/game-design.md`
   - Format: `[YYYY-MM-DD HH:MM:SS] generate-game-design: Updated docs/game-design.md`
   - Keep entries minimal and chronological (newest first)
   - Save the changelog file

10. **Review and Refine**
   - Present the game design document to the user
   - Verify that it focuses on mechanics and not flows/UI
   - Confirm that mechanics are clearly specified for programmers
   - Check that tweakable parameters are identified
   - Refine based on feedback

## Output Format Guidelines

- **Mechanic descriptions** should be clear and unambiguous
- **Avoid flow language** like "player clicks", "screen shows", "menu appears"
- **Focus on behavior** like "ball bounces", "block breaks", "power-up activates"
- **Use programmer-friendly terminology** where appropriate (e.g., "entity", "component", "system")
- **Parameter names** should be clear and descriptive (e.g., `ballBaseSpeed`, `blockHealth`, `powerUpSpawnChance`)

## Example Structure

```markdown
# Game Design: [Game Name]

## Overview
[Brief summary focusing on core mechanics]

## Core Mechanics

### [Mechanic Name]
**Description**: [What it does]
**Rules**: 
- [Rule 1]
- [Rule 2]
**Triggers**: [When it activates]
**Effects**: [What happens]
**Interactions**: [How it relates to other mechanics]
**Tweakable Parameters**:
- `parameterName`: [Description and suggested range/default]

## Tweakable Parameters Summary
[Organized list of all parameters]
```

